input { 
    stdin { type => 'test' } 
    tcp { type => "beer" port => 3333 tags => ["beer","apache","access"] }
    tcp { type => "classic" port => 3334 tags => ["classic","apache","access"] }
    tcp { type => "bit_server" port => 3335 }
    tcp { type => "data_server" port => 3336 }
    tcp { type => "error" port => 3337 tags => ["apache","error"] }
    redis {
        host => 'localhost'
        data_type => 'list'
        key => 'logstash:beer'
        type => 'beer'
        tags => ["beer"]
    }
    redis {
        host => 'localhost'
        data_type => 'list'
        key => 'logstash:classic'
        type => 'classic'
        tags => ["classic"]
    }
}

filter {
    # beer apache access log
    grok {
        tags => ["beer","apache","access"]
        match => ["@message", "%{COMBINDEDWITHRESPTIME}"]
    }

    # classic apache access log
    grok {
        tags => ["classic","apache","access"]
        match => ["@message", "%{COMBINEDWITHCOOKIE}"]
        add_tag => ["access","classic"]
    }

    # should handle dates for classic & beer apache access
    date {
        tags => ["apache","access"]
        match => [ "timestamp", "dd/MMM/yyyy:HH:mm:ss Z" ]
    }

    # should handle both apache error logs
    grok {
        tags => ["apache","error"]
        match => ["@message", "%{GENERICAPACHEERROR}"]
    }
#    multiline {
#        tags => ["apache","error"]
#        what => "next"
#        pattern => "\]\s\s+."
#    }

    # remove quotes from some values
    mutate {
        tags => ["apache","access"]
        gsub => [
            "referrer", "\"", "",
            "cookie", "\"", "",
            "agent", "\"", "",
            "proxy", "\"", ""
        ]
    }

    urldecode {
        tags => ["apache","access"]
        all_fields => true
    }

    kv {
        tags => ["apache","access"]
        source => ["qstring"]
        target => "params"
        field_split => "?&"
        value_split => "="
    }
    kv {
        tags => ["apache","access"]
        source => ["cookie"]
        target => "cookie_vals"
        field_split => "; "
        value_split => "="
    }
    grep {
        tags => ["apache","access"]
        match => ["path", "/api/"]
        drop => false
        add_tag => ["api"]
    }

    # ads bit server log
    grok {
        type => "bit_server"
        match => ["@message", "%{ADSBITSERVER}"]
        add_tag => ["access","classic"]
    }
    # ads data server log
    grok {
        type => "data_server"
        match => ["@message", "%{ADSDATASERVER}"]
        add_tag => ["access","classic"]
    }
    mutate {
        tags => ["classic","access"]
        gsub => [
            "logdate", "\b(?<val>\d)\b", "0\k<val>",
            "logdate", "\s+", " "
        ]
    }
    date {
        tags => ["classic","access"]
        match => [ "logdate", "yyyy MM dd HH mm ss" ]
    }

    # do a reverse lookup on the ip...
    dns {
        action => "replace"
        reverse => ["client_addr"]
        add_tag => ["dns_reversed"]
    }
    # ... then check if it matches a bot or known "client" software
    grok {
        tags => ["dns_reversed"]
        match => ["client_addr", "%{BOTORCLIENT:bot_or_client}"]
        tag_on_failure => false
    }
}
output {
    stdout { debug => true }
    elasticsearch_http {
        flush_size => 1000
    }
}
